# 自动命令组

前面几章我们学习了自动命令。执行下面命令：

```
:autocmd BufWrite * :echom "Writing buffer!"
```

现在使用`:write`命令将当前缓冲区写入文件，然后执行`:messages`命令查看消息日志。你会看到`Writing buffer!`在消息列表中。

然后将当前缓冲区写入文件，执行`:messages`查看消息日志。你会看到`Writing buffer!`在消息列表中出现了两次。

现在再次执行上面的自动命令：

```
:autocmd BufWrite * :echom "Writing buffer!"
```

再次将当前缓冲区写入文件并执行`:messages`命令。你会看到`Writing buffer!`在消息列表中出现了*4*次，这是怎么回事？

这是因为当你以上面的方式创建第二个自动命令的时候，Vim没办法知道你是想替换第一个自动命令。在上面的示例中，Vim创建了两个*不同*的自动命令，并且这两个命令刚好做同样的事情。

## 这会有什么问题？

既然你现在知道了Vim可能创建两个完全一样的自动命令，你可能会想：“有什么大不了？只要别这么干就可以！”。

问题是当你加载你的`~/.vimrc`文件的时候，Vim会重新读取整个文件，包括你所定义的任何自动命令！这就意味着每次你加载你的`~/.vimrc`文件的时候，Vim都会复制之前的自动命令，这会降低Vim的运行速度，因为它会一次又一次地执行相同的命令。

你可以执行下面的命令模拟这种情况：

```
:autocmd BufWrite * :sleep 200m
```

现在将当前缓冲区写入文件。你可能注意到Vim在写入文件的时候有点缓慢，当然也你可能注意不到。现在执行上面的自动命令三次：

```
:autocmd BufWrite * :sleep 200m
:autocmd BufWrite * :sleep 200m
:autocmd BufWrite * :sleep 200m
```

再次写文件。这次会更明显。

当然你不会创建任何只是进行sleep而不做任何事情的自动命令，不过一个使用Vim的老鸟的`~/.vimrc`文件可以轻易达到1000行，其中会有很多自动命令。再加上安装的插件中的自动命令，这肯定会影响Vim的速度。

## 把自动命令放到组中（Grouping Autocommands）

对于这个问题，Vim有一个解决方案。这个解决方案的第一步是将相关的自动命令收集起来放到一个已命名的组（groups）中。

新开一个Vim实例，这样可以清除之前所创建的自动命令。然后运行下面的命令：

```
:augroup testgroup
:    autocmd BufWrite * :echom "Foo"
:    autocmd BufWrite * :echom "Bar"
:augroup END
```

中间两行的缩进没有什么含义，如果你不想输入的话可以不输。

将一个缓冲区写入文件然后执行`:messages`。你应该可以在消息日志列表中看到`Foo`和`Bar`。现在执行下面的命令：

```
:augroup testgroup
:    autocmd BufWrite * :echom "Baz"
:augroup END
```

当你再次将缓冲区写入文件的时候猜猜会发生什么。ok，你也许已经有结果了，重新写入缓冲区，然后执行`:messages`命令，看看你猜对了没。 

## 清除自动命令组

当你写入文件的时候发生什么了？猜对了么？

如果你认为Vim会替换那个组，那么你猜错了。不要紧，很多人刚开始的时候都会这么想（我也是）。

当你多次使用`augroup`的时候，Vim每次都会组合那些组。

如果你想清除一个组，你可以把`autocmd!`这个命令包含在组里面。执行下面的命令：

```
:augroup testgroup
:    autocmd!
:    autocmd BufWrite * :echom "Cats"
:augroup END
```

现在试试写入文件然后执行`:messages`查看消息日志。这次Vim只会输出`Cats`在消息列表中。

## 在Vimrc中使用自动命令

既然我们现在知道了怎么把自动命令放到一个组里面以及怎么清除这些组，我们可以使用这种方式将自动命令添加到`~/.vimrc`中，这样每次加载它的时候就不会复制自动命令了。

添加下面的命令到你的`~/.vimrc`文件中：

```
augroup filetype_html
    autocmd!
    autocmd FileType html nnoremap <buffer> <localleader>f Vatzf
augroup END
```

当进入`filetype_html`这个组的时候，我们会立即清除这个组，然后定义一个自动命令，然后退出这个组。当我们再次加载`~/.vimrc`文件的时候，清除组命令会阻止Vim添加一个一模一样的自动命令。

## 练习

查看你的`~/.vimrc`文件，然后把所有的自动命令用上面组的方式包裹起来。如果你觉得有必要，可以把多个自动命令放到一个组里面。

想想上一节的示例中的自动命令是干啥的。

阅读`:help autocmd-groups`。



# 负责任的编码

到目前为止我们已经介绍了一堆Vim命令，这可以让你可以快速自定义Vim。除了自动命令组外其他的命令都是单行的命令，你可以不费吹灰之力就把它们添加到你的`~/.vimrc`文件中。

这本书的下一部分我们会开始专注于Vim脚本编程，将其当作一个真正的编程语言对待，不过在此之前，我会先讲一些在编写大量的Vim脚本时需要注意的东西。

## 注释

Vim脚本非常强大，但对于那些想进入这个领域的程序员而言，在最近几年它似乎逐渐变得像一个弯弯曲曲的迷宫，让进入的人找不到归路。

Vim的选项和命令经常会比较简短生硬，并且难于阅读，另外处理兼容性问题也会增加代码的复杂度。编写一个插件并且允许用户自定义又会让复杂度更进一级。

在编写大量Vim脚本时要保持防御意识。要养成习惯添加注释说明某段代码是干什么的，如果有一个相关的帮助主题（help topic），最好在注释中说明！

这不仅会给你以后的维护带来方便，而且如果你将你的`~/.vimrc`文件分享到Bitbucket或者GitHub（强烈推荐你这么做），这些注释也会帮助其他的人理解你的脚本。

## 分组

之前创建的映射可以让我们在使用Vim的同时方便快捷地编辑和加载`~/.vimrc`。不幸的是这会导致`~/.vimrc`中的代码快速增长以至失去控制，并且变得难于阅读浏览。

我们用于对付这种情况的方法是使用Vim的代码折叠功能，将多行代码组织起来的作为一个部分然后对这部分的代码进行折叠。如果你从来没有用过Vim的折叠功能，那么你现在应该尽快去瞄一瞄。很多人（包括我自己）都认为在日常编码工作中代码折叠是不可或缺的。

首先我们需要为Vim脚本文件设置折叠。在你的`~/.vimrc`文件中添加下面几行：

```
augroup filetype_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
augroup END
```

这会告诉Vim对任何Vim脚本文件使用`marker`折叠方法。

现在在显示`~/.vimrc`文件的窗口中执行`:setlocal foldmethod=marker`。如果你不执行这个命令，你会发现加载`~/.vimrc`文件后没什么效果，这是因为Vim已经为这个文件设置了文件类型(FileType)，而自动命令只会在设置文件类型的时候执行。这让你以后不需要手动来做这个事情。

现在在自动命令组开始和结束的地方添加两行，像下面这样：

```
" Vimscript file settings ---------------------- {{{
augroup filetype_vim
    autocmd!
    autocmd FileType vim setlocal foldmethod=marker
augroup END
" }}}
```

切换到常用模式，将光标放到这些文字中的任意一行，然后敲击`za`。Vim会折叠从包含`{{{`的行到包含`}}}`的行之间的所有行。再敲击`za`会展开所有这些行。

刚开始你可能会觉得为了代码折叠而对源代码进行注释会有些不合理，我刚开始也这么想。对于大多数文件我现在仍然觉得这种做法并并不合适。因为不是所有人都使用相同的编辑器，所以在代码中添加的折叠注释对于那些不用Vim的人而言就像是噪音。

不过Vim脚本文件比较特殊，因为一个不用Vim的人不太可能会读你的代码，并且最重要的是如果不对代码进行分组处理，写着写着你就不知道写到哪里了，严重点可能会经脉尽断，吐血而亡。

先自己尝试尝试吧，说不定你会逐渐喜欢上它。

## 简短的名称(Short Names)

对于大多数命令和选项，Vim支持使用它们的缩写。例如，下面的两个命令做的事情完全一样：

```
:setlocal wrap
:setl wrap
```

我*强烈*提醒你不要在你的`~/.vimrc`或者是你编写的插件中使用这些缩写。Vim脚本对于初学者而言本来就已经够晦涩难懂了；从长远来看使用缩写只会使得它更难于阅读。即使*你*知道某个缩写的意思，其他人未必读得懂。

换句话说，缩写只在编码的过程中手动执行命令的时候会*很有用*。在你按了回车键以后，就没人会看到你输入什么了，这样你也没必要输入更多的字符。

## 练习

检查你的`~/.vimrc`文件，将所有相关的行组织起来。你可以这么开头：“基本设置(Basic Settings)“，”文件类型相关设置(FileType-specific settings)”，“映射(Mappings)”，和“状态条(Status Line)”。然后在每个部分添加折叠标记和标题。

想想怎么让Vim在第一次打开`~/.vimrc`文件的时候自动折叠所有设置了折叠注释的行。阅读`:help foldlevelstart`你会知道怎么搞。

检查你的`~/.vimrc`文件，把所有的命令和选项的缩写改成全称。

检查你的`~/.vimrc`文件，确保里面没有什么敏感信息。然后创建一个git或者Mercurial仓库，再将`~/.vimrc`文件放到里面，然后将这个文件链接到`~/.vimrc`。

提交你刚才创建的仓库，并把它放到Bitbucket或者GitHub上，这样其他的人都可以看到和学习它。记住要经常提交和推送到仓库中，这样你所做的修改也会被记录下来。

如果你不只在一个机器上使用Vim，那你就可以克隆那个仓库，然后像之前一样将这个文件链接到`~/.vimrc`文件。这样你就可以在所有的机器上都使用同样的Vim配置了。

# 条件语句

每种编程语言都有产生分支流程的方法，在Vimscript中，这是用`if`语句实现的。 `if`语句是Vimscript中产生分支的基本方法。这里没有类似Ruby中的`unless`语句， 所以代码中所有的判断都需要用`if`实现。

在谈论Vim的`if`语句之前，我们需要花费额外的时间讲讲语法，这样可以在同一页里讲完它。

## 多行语句

有时你在一行里写不下所需的Vimscript。在讲到自动命令组时，我们已经遇到过这样的例子了。 这里是我们之前写过的代码：

```
:augroup testgroup
:    autocmd BufWrite * :echom "Baz"
:augroup END
```

在理想的情况下，你可以分开成三行来写。但在手工执行命令的时候，这样写就太冗长了。 其实，你可以用管道符(`|`)来隔开每一行。执行下面的命令：

```
:echom "foo" | echom "bar"
```

Vim会把它当作两个独立的命令。如果你看不到两行输出，执行`:messages`查看消息日志。

在本书的剩余部分，当你想手工执行一个命令，却对输入新行和冒号感到心烦时，试试用管道隔开， 在一行里写完。

## If的基本用法

现在让我们回到正题上来，执行下面的命令：

```
:if 1
:    echom "ONE"
:endif
```

Vim将显示`ONE`，因为整数`1`是"truthy"。现在执行下面命令：

```
:if 0
:    echom "ZERO"
:endif
```

Vim将*不*显示`ZERO`，因为整数`0`是"falsy"。让我们看看对字符串是怎么处理的。执行下面命令：

```
:if "something"
:    echom "INDEED"
:endif
```

结果可能让你吃惊。Vim*不会*把非空字符串当作"truthy"，所以什么也没有显示。

让我们打破沙锅问到底。执行下面的命令：

```
:if "9024"
:    echom "WHAT?!"
:endif
```

这次Vim*会*显示了！为什么会这样？

为了搞懂发生了什么，执行下面三个命令：

```
:echom "hello" + 10
:echom "10hello" + 10
:echom "hello10" + 10
```

第一个命令使得Vim输出`10`，第二个命令输出`20`，第三个则又一次输出`10`！

在探究了所有的命令后，对于Vimscript我们可以得出结论：

- 如有必要，Vim将强制转换变量(和字面量)的类型。在解析`10 + "20foo"`时，Vim将把`"20foo"`转换成一个整数(`20`)然后加到`10`上去。
- 以一个数字开头的字符串会被强制转换成数字，否则会转换成`0`
- 在所有的强制转换完成*后*，当`if`的判断条件等于非零整数时，Vim会执行`if`语句体。

## Else 和 Elseif

Vim，像Python一样，支持"else"和"else if"分句。执行下面的命令：

```
:if 0
:    echom "if"
:elseif "nope!"
:    echom "elseif"
:else
:    echom "finally!"
:endif
```

Vim输出`finally!`，因为前面的判断条件都等于0，而0代表falsy。

## 练习

来一杯啤酒，安抚自己因Vim中的字符串强制转换而受伤的心。